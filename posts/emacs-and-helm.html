<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>the scratch castle: Why I Use Helm and Why You Should Too</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700' rel='stylesheet'
          type='text/css'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
    <script src="https://localhost:35729/livereload.js"></script>
  </head>
  <body>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-74092852-1', 'auto');
      ga('send', 'pageview');
    </script>
    <div class="container">
      <div class="simple-nav">
        <h3 class="simple-nav-title">the scratch castle</h3>
        <pre class="simple-nav-toggle"> _   _   _             _   _   _
| |_| |_| |           | |_| |_| |
 \ _____ /      o_     \ _____ /
  |     |       |_|     |     |
  |  |  |       |       |  |  |
  |   _ | _   _ | _   _ | _   |
  |  | |_| |_| ||| |_| |_| |  |
  |  |                     |  |
  || |                     | ||
  |  |        _____        |  |
  |  |       /_|_|_\       |  |
  |  |      /|_|_|_|\      |  |
  |  |      ||_|_|_||      |  |
  |  |      ||_|_|_||      |  |
  |__|      ||_|_|_||      |__|
 /   |      ||_|_|_||      |   \
=================================
</pre>
        <div class="row">
          <div class="col-8 col-offset-2">
            <div class="row link-container">
              <a class="col-xs-4 simple-nav-link " href="/index.html">
                <div class="wrapper-container"></div>
                home
              </a>
              <a class="col-xs-4 simple-nav-link " href="/pages/about.html">
                <div class="wrapper-container"></div>
                about
              </a>
              <a class="col-xs-4 simple-nav-link" href="/feed.xml">
                <div class="wrapper-container"></div>
                rss
              </a>
            </div>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-10 col-offset-1">
          <div id="content">
            
<div id="post">
    <div class="post-header">
    <h2>Why I Use Helm and Why You Should Too</h2>
    <div id="post-meta" class="row">
        <div class="col-lg-6">February 18, 2016</div>
        
    </div>
</div>
<div>
    
    <p>Emacs is a whirlwind of shortcuts and commands for a beginner. Because Emacs isn't a true modal editor like VIM you must learn a plethora of keyboard shortcuts to edit text efficiently.  Richard Stallman, the creator of GNU Emacs, was well aware of this so he created the "GNU Emacs Human Interface Machine", which was a specially designed keyboard for Emacs power users.</p><p>The picture below is an example of one of these machines.</p><p><figure> <img src="/img/emacs-human-interface-machine.jpg"></img> <figcaption> The GNU Emacs Human Interface Machine <figcaption> The keyboard impressed its users so much that they often felt compelled to put on a suit before operating it! </figcaption> </figcaption> </figure></p><p>All joking aside, Emacs's default interface isn't very user friendly when you don't know the shortcut or command name you want to execute.  When you run a command that requires user input, you're given an empty prompt. That's it.  If you read the tutorial then you may remember that you can press TAB to see some options. That's a little better I suppose, but it would be better if you could see your possibilities without asking for it.  Enter helm.</p><p><a href='https://github.com/emacs-helm/helm'>Helm</a> is an extension package for Emacs that, among other things, hooks into many of the commands requiring user input and supplants them with a new command that presents the user with a prompt AND an interactive list of options that is fuzzy matched to what is typed in that prompt. It's sort of similar to the <a href='http://docs.sublimetext.info/en/latest/file_management/file_management.html'>goto anything</a> commands that are available in Sublime Text, except it's available  on more than just a handful of commands.</p><p>Say I want to find a window command that splits the window into two vertical halves and all I know is that the command has 'window' and 'split' in its name and I'm not sure which term is first.  Helm makes it extremely easy to browse the available symbols(names) in the current Emacs environment using the 'helm-apropos' command.</p><p><img src="/img/helm-apropos.gif" alt="" /></p><p>In the demo above, I run 'helm-apropos' and try searching for a command that has 'window' followed by 'split' in its name.  I find nothing appropriate so I try the reverse and search for a command with 'split' followed by 'window' in its name.  I eventually find the correct answer which is 'split-window-right'.</p><p>There's an important feature to note about this kind of UI that isn't immediately obvious.  Because you're presented with all the possibilities, you end up learning the capabilities of the program by simply using the program.  Because of this side effect, Emacs became a much more understandable system after I installed helm. It's such a boon to the Emacs experience that I would consider changing editors if helm wasn't available.</p><p>Below I outline some useful helm commands followed by my favorite helm extension packages.</p><h2><a name="built-in&#95;helm&#95;commands"></a>Built-In Helm Commands</h2><h3><a name="helm-find-file&#95;/&#95;bound&#95;to&#95;c-x&#95;c-f"></a>helm-find-file / Bound to C-x C-f</h3>Use this command to navigate your file system and open files.  The 'helm-find-file' command presents you with a list of files in your current working directory.  Pressing C-l will move you up to the parent's directory.  If your cursor is on a directory, C-j will move you into it.  Press RETURN to open a file.  Easy peasy.<p><img src="/img/helm-find-file.gif" alt="Demo" /></p><h3><a name="helm-m-x&#95;/&#95;bound&#95;to&#95;c-m"></a>helm-M-x / Bound to C-m</h3>This command is similar to 'helm-apropos' except you're only presented with commands and pressing RETURN on a command will execute that command.<p><img src="/img/helm-M-x.gif" alt="Demo" /></p><p>Use helm-M-x as an alternative to typing M-x.</p><h3><a name="helm-google&#95;/&#95;no&#95;default&#95;binding"></a>helm-google / No default binding</h3>Search Google with helm.  The nice thing about this command is that results are populated as you type, just like searching Google in a browser.  Press RETURN on a result to open the link in your default browser.<p><img src="/img/helm-google.gif" alt="Demo" /></p><h3><a name="helm-apropos&#95;/&#95;bound&#95;to&#95;c-x&#95;c&#95;a"></a>helm-apropos / Bound to C-x c a</h3>helm-apropos shows you the symbols of every possible command, function, variable, and face that is available in Emacs.  Think of it as a list of everything you can do and everything that is defined in Emacs.  Press RETURN on an item to see the help associated with it.</br></br>An important thing to note about this command is that the list of symbols may change throughout the Emacs process's lifetime.  That's because Emacs is, for lack of a better term, clay.  You may not be aware of this but Emacs is a living, breathing Lisp environment.  You can change the meaning of defined symbols on-the-fly or add new definitions without having to restart Emacs.  This is the magic behind those demos you might have seen of programming in a <a href='https://www.youtube.com/watch?v=7XUWpze_A_s'>live lisp environment</a>.<h2><a name="helm&#95;extensions"></a>Helm Extensions</h2><h3><a name="helm-dash"></a>helm-dash</h3><p>The helm-dash package lets you search programming language  documentation through "docsets" you've installed on your machine.  Install docsets for a language using the 'helm-dash-install-docset'  command and search them using the 'helm-dash' command.  Press RETURN  on a result to open the documentation in your default browser.</p><p><a href='https://github.com/areina/helm-dash'>helm-dash github</a></p><h3><a name="evalator"></a>evalator</h3><p>Evalator is a new kind of REPL that I wrote for Emacs that lets  you interactively transform data. It evaluates expressions in   Emacs Lisp by default but it can support any language provided  you've installed the evaluation context package.</p><p>I use evalator mainly as a calculator and a quick experimentation tool  when I'm writing Emacs Lisp and Clojure code.  It feels much quicker  than using a normal REPL because expressions are evaluated  automatically.</p><p>Evalator starts with a prompt where you supply an expression to  generate the initial data.  Following expressions transform that data  on a per-element basis so its very easy to transform lists and other  collections.  You can also use evalator in explicit mode, which allows  you to transform data as usual, but it lets you generate the  equivalent code of the entire transformation.</p><p><a href='https://github.com/seanirby/evalator'>evalator github</a></p><h3><a name="helm-descbinds"></a>helm-descbinds</h3>I really love this one.  helm-descbinds shows you all the shortcuts  that can be executed based on your current major-mode and minor modes.</br></br><a href='https://github.com/emacs-helm/helm-descbinds'>helm-descbinds github</a><h3><a name="helm-projectile"></a>helm-projectile</h3>If you've ever wanted to browse all the files in a particular directory ala Sublime Text then you want helm-projectile.</br></br>helm-projectile is a helm extension for the projectile package, which provides utilities for managing your programming projects.  A project is essentially a folder with files.  Projects are automatically added to projectile if they have a VCS directory like a '.git' or '.svn'.</br></br>There are tons of useful projectile commands I could demo, but <a href='http://tuhdo.github.io/helm-projectile.html'>tuhdo covered this better than I ever could</a>.<p><a href='http://tuhdo.github.io/helm-projectile.html'>helm-projectile github</a></p><p>I hope by now that I've convinced you to check out helm.  It really  is an innovative way of interacting with Emacs.</p><p><a href="#" name="update"></a><h2><a name="update&#95;(2/18/2016):"></a>UPDATE (2/18/2016):</h2></p><p>After sharing this article on the <a href='https://reddit.com/r/emacs'>Emacs subreddit</a>, I received an excellent comment from an Emacs package author I admire very much, <a href='https://github.com/abo-abo'>Oleh Krehel</a>, AKA abo-abo.  He makes <a href='https://github.com/abo-abo/hydra'>some</a> <a href='https://github.com/abo-abo/lispy'>very</a> <a href='https://github.com/abo-abo/avy'>innovative</a> <a href='https://github.com/abo-abo/swiper'>tools</a> for Emacs including a completion framework called <a href='http://oremacs.com/2015/04/16/ivy-mode/'>ivy</a>,  which many Emacs users prefer to helm.</p><p>In his reply, Oleh argues that if the built-in Emacs function <code>completing-read</code> were updated, then packages that extend helm could be used in all the different completion frameworks.  This includes ivy, icicles, ido, and others.  <a href='https://www.reddit.com/r/emacs/comments/46ibsx/why_i_use_helm_and_why_you_should_too/d05pdow'>Here's the conversation</a> and I've included his comment below(formatting has been added):</p><p><blockquote> Nice article, very good-looking presentation.</p><p>However, you repeat the opinion that the completion (which is a great thing to have) is welded to the method of presenting said completion (in this case, Helm). Many other people do this as well, with 112 packages in MELPA having "helm-" in their name. Hard-wiring completion to helm prevents access to ~100 packages for users that like other methods of presenting completion.</p><p>In the short run, it's convenient to live in Helm's bubble: assume that Helm is all you'll ever need and hard-wire everything to Helm. But most helm-foo packages out there simply consist of three things:</p><ol><li>Functions that generate the list of strings.</li><li>Functions that take a single string - the selected candidate, and do something with it.</li><li>The helm glue that wires the first group to the second.</li></ol><p>The non-helm people could make use of the functions in group-1 and group-2. The two problems they face: There's no glue. This could be solved by completing packages relying on the built-in <code>completing-read</code> more. There's a helm dependency. This isn't severe, but if you don't use helm you don't want to pay the overhead of <code>(require 'helm)</code> and having to update helm from the package manager.</p><p>These two problems can be solved eventually by having a better completing-read API in the core. So that a package that only wants to provide completion can call completing-read and not be tied to any completion presentation framework. Two new parameters would be especially good to have: action - a lambda that decides what to do with the selected candidate, and caller - a symbol that identifies the completion session for purposes of customization (since this-command isn't reliable).</p><h2><a name="example&#95;translation"></a>Example translation</h2><h3><a name="before:"></a>Before:</h3><p>Here we have helm-rhythmbox, an excellent package that provides a function from group-1 - <code>helm-rhythmbox-candidates</code> that produces a list of songs on your system; and two functions from group-2 - <code>helm-rhythmbox-play-song</code> and <code>helm-rhythmbox-enqueue-song</code> that act on the selected song.</p><pre><code>&#40;defvar helm-source-rhythmbox-track-search
'&#40;&#40;name . &quot;Rhythmbox&quot;&#41;
    &#40;candidates . helm-rhythmbox-candidates&#41;
    &#40;action . &#40;&#40;&quot;Play song&quot; . helm-rhythmbox-play-song&#41;
            &#40;&quot;Enqueue song&quot; . helm-rhythmbox-enqueue-song&#41;&#41;&#41;
    &#40;init . &#40;lambda &#40;&#41; &#40;unless rhythmbox-library
                    &#40;rhythmbox-load-library&#41;&#41;&#41;&#41;&#41;&#41;
;;;###autoload
&#40;defun helm-rhythmbox &#40;&#41;
    &quot;Choose a song from the Rhythmbox library to play or enqueue.&quot;
    &#40;interactive&#41;
    &#40;helm :sources '&#40;helm-source-rhythmbox-track-search&#41;
            :buffer &quot;&#42;helm-rhythmbox&#42;&quot;&#41;&#41;</code></pre><h3><a name="after:"></a>After:</h3><pre><code>;;;###autoload
&#40;defun rhythmbox &#40;&#41;
    &quot;Choose a song from the Rhythmbox library to play or enqueue.&quot;
    &#40;interactive&#41;
    &#40;unless rhythmbox-library
        &#40;rhythmbox-load-library&#41;&#41;
    &#40;completing-read &quot;Rhythmbox: &quot; &#40;helm-rhythmbox-candidates&#41;
                    nil nil nil nil nil nil
                    'helm-rhythmbox-play-song
                    'rhythmbox&#41;&#41;
;; ideally, the following sections are not needed at all
&#40;eval-after-load 'helm
;; non-essential helm-specific customization via the 'rhythmbox key
&#41;
&#40;eval-after-load 'ivy
;; non-essential ivy-specific customization via the 'rhythmbox key
&#41;</code></pre><p>Now we have a rhythmbox command that could act in exactly the same way as helm-rhythmbox when helm-mode (available with Helm) is on. But this command would also work excellently with Ivy or Ido or Icicles or Icomplete or built-in completion. This command could live in a rhythmbox package that does not depend on helm, since it doesn't use anything Helm-specific.</p><p></blockquote></p><p>I'm glad Oleh joined in on the discussion and I think he makes a great case for why the <code>completing-read</code> function should be updated.  Thanks Oleh!</p><p>— sean</p>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags-output/helm.html">helm</a>
    
    <a href="/tags-output/emacs.html">emacs</a>
    
    <a href="/tags-output/UI.html">UI</a>
    
</div>


    <div id="prev-next">
        
        
        <a class="right" href="/posts/a-simple-keyboard-macro-demo.html">A Simple Keyboard Macro Demo &raquo;</a>
        
    </div>

    


</div>

          </div>
        </div>
      </div>

      <footer>Copyright &copy;  Sean Irby
        <p style="text-align: center;">Powered by <a href="http://cryogenweb.org">Cryogen</a></p>
      </footer>
    </div>

    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src="/js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
